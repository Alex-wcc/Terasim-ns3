
#include <ns3/thz-spectrum-propagation-loss-model.h>
#include <ns3/thz-spectrum-model.h>
#include <ns3/mobility-model.h>
#include <cmath> // for M_PI
#include <iostream>
#include <string>
#include <fstream>
#include <ns3/log.h>

NS_LOG_COMPONENT_DEFINE ("THzSpectrumPropagationLossModel");

namespace ns3
{

NS_OBJECT_ENSURE_REGISTERED (THzSpectrumPropagationLossModel);

THzSpectrumPropagationLossModel::THzSpectrumPropagationLossModel ()
{
}

THzSpectrumPropagationLossModel::~THzSpectrumPropagationLossModel ()
{
}

TypeId THzSpectrumPropagationLossModel::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::THzSpectrumPropagationLossModel")
    .SetParent<TSpectrumPropagationLossModel> ()
    .AddConstructor<THzSpectrumPropagationLossModel> ()
  ;
  return tid;
}


Ptr<SpectrumValue>
THzSpectrumPropagationLossModel::DoCalcRxPowerSpectralDensity (Ptr<const SpectrumValue> txPsd,
                                                                 Ptr<const MobilityModel> a,
                                                                 Ptr<const MobilityModel> b) const
{
  Ptr<SpectrumValue> rxPsd = Copy<SpectrumValue> (txPsd);
  Values::iterator vit = rxPsd->ValuesBegin ();
  Bands::const_iterator fit = rxPsd->ConstBandsBegin ();

  NS_ASSERT (a);
  NS_ASSERT (b);

  double d = a->GetDistanceFrom (b);

  while (vit != rxPsd->ValuesEnd ())
    {
      NS_ASSERT (fit != rxPsd->ConstBandsEnd ());
      *vit /= (CalculateSpreadLoss (fit->fc, d) * CalculateAbsLoss (fit->fc, d)); // Prx = Ptx / loss
      ++vit;
      ++fit;
    }
  return rxPsd;
}

//-----------------------------------------------------------------------------------------------------//


double
THzSpectrumPropagationLossModel::DoCalcRxPower (double txPowerDbm,
                                                Ptr<MobilityModel> a,
                                                Ptr<MobilityModel> b) const
{
  
  double txPowerW = std::pow(10.0, txPowerDbm/10.0);
  txPowerW = txPowerW/1000.0;
  THzSpectrumValueFactory sf;
  Ptr<SpectrumValue> txPsd = sf.CreateTxPowerSpectralDensity (txPowerW, 24); 
  Ptr<SpectrumValue> rxPsd = Copy<SpectrumValue> (txPsd);
  Values::iterator vit = rxPsd->ValuesBegin ();
  Bands::const_iterator fit = rxPsd->ConstBandsBegin ();

  NS_ASSERT (a);
  NS_ASSERT (b);
  double d = a->GetDistanceFrom (b);
  double rxPsd_inte = 0.0;
  while (vit != rxPsd->ValuesEnd ())
    {
      NS_ASSERT (fit != rxPsd->ConstBandsEnd ());
      *vit /= (CalculateSpreadLoss (fit->fc, d) * CalculateAbsLoss (fit->fc, d)); // Prx = Ptx / loss
      ++vit;
      ++fit;
      rxPsd_inte += *vit;
    }
  double rxPower = rxPsd_inte * 0.09894e10 * 100;
  return rxPower;  

}

double
THzSpectrumPropagationLossModel::DoCalcRxPowerPulse (Ptr<SpectrumValue> txPsd,
                                                Ptr<MobilityModel> a,
                                                Ptr<MobilityModel> b) const
{
  NS_LOG_FUNCTION ("");
  Ptr<SpectrumValue> rxPsd = Copy<SpectrumValue> (txPsd);
  Values::iterator vit = rxPsd->ValuesBegin ();
  Bands::const_iterator fit = rxPsd->ConstBandsBegin ();

  NS_ASSERT (a);
  NS_ASSERT (b);
  double d = a->GetDistanceFrom (b);
  double rxPsd_inte = 0.0;
  NS_LOG_INFO ("distance"<<d);
  while (vit != rxPsd->ValuesEnd () && *vit > 0 )
    {
      NS_ASSERT (fit != rxPsd->ConstBandsEnd ());
      *vit /= (CalculateSpreadLoss (fit->fc, d) * CalculateAbsLoss (fit->fc, d)); // Prx = Ptx / loss
      //NS_LOG_INFO ("vit"<<*vit);
      rxPsd_inte += *vit;
      ++vit;
      ++fit;
      
    }
  double rxPower = rxPsd_inte * 0.09894e10 * 100;
  rxPower *= 1000;
  rxPower = 10 * log10 (rxPower);
  NS_LOG_INFO ("rxpower: "<<rxPower<<"dBm");
  return rxPower;  
  
}
//-----------------------------------------------------------------------------------------------------//
double
THzSpectrumPropagationLossModel::CalculateSpreadLoss (double f, double d) const
{
  NS_ASSERT (d >= 0);

  if (d == 0)
    {
      return 1;
    }

  NS_ASSERT (f > 0);
  double loss_sqrt = (4 * M_PI * f * d) / 3e8;
  double loss = loss_sqrt * loss_sqrt;

  if (loss < 1)
    {
      loss = 1;
    }
  return loss;
}

double
THzSpectrumPropagationLossModel::CalculateAbsLoss (double f, double d) const
{
  std:: ifstream AbsCoefile;
  AbsCoefile.open ("kv.txt", std::ifstream::in); 
  std:: ifstream frequencyfile;
  frequencyfile.open ("f.txt", std::ifstream::in);                  
  double f_ite;                  
  double k_ite; 
  double kf = 0.0;
  double loss;
  int i = 0;
  int j = 0;
  
 
  while (frequencyfile>> f_ite)
  {
    if (f_ite != f)
     {
       j++;
     }
    else break;
  }

  while (AbsCoefile>> k_ite)
  {  
    if (i != j)
      {
        i++;
      }
    else 
      {
        kf = k_ite;
        break;
      }
        NS_ASSERT (d >= 0);

        if (d == 0)
          {
            return 1;
          }
        NS_ASSERT (f > 0);
        loss = exp (kf * d);
   }    
    if (loss < 1)
      {
        loss = 1;
      }
    return loss;        
}



Ptr<SpectrumValue>
THzSpectrumPropagationLossModel::LoadedAbsCoe (int s, int j, double f, double d,Ptr<const SpectrumValue> txPsd) const
{
  std:: ifstream AbsCoefile;
  AbsCoefile.open ("kv.txt", std::ifstream::in);                  
  double k; 
  Ptr<SpectrumValue> kf_store = Copy <SpectrumValue> (txPsd);
  int i = 1;

  while (AbsCoefile>> k)
  {  
    if (i < s)
      {
        i++;
      }
    else if (i > j) 
      {
        break;
      }
    else 
      {
        (*kf_store)[i-s] = k;
        i++;
      }
   } 
  return kf_store;
}




}
