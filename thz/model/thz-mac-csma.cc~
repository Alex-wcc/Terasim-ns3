/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */


#include "ns3/attribute.h"
#include "ns3/uinteger.h"
#include "ns3/boolean.h"
#include "ns3/double.h"
#include "ns3/nstime.h"
#include "ns3/random-variable.h"
#include "ns3/log.h"
#include "ns3/trace-source-accessor.h"
#include "ns3/node.h"
#include "ns3/rng-seed-manager.h"
#include "thz-energy-model.h"
#include "thz-dir-antenna.h"

#include "thz-mac-header.h"
#include "thz-mac-csma.h"

#include <vector>
#include <iostream>

NS_LOG_COMPONENT_DEFINE ("THzMacCsma");

namespace ns3 {

NS_OBJECT_ENSURE_REGISTERED (THzMacCsma);

THzMacCsma::THzMacCsma ()
  : THzMac (),
    m_phy (0),
    /*m_state (IDLE),
    //m_ccaTimeoutEvent (),
    m_backoffTimeoutEvent (),
    m_ctsTimeoutEvent (),*/
    //m_ackTimeoutEvent (),
    //m_sendCtsEvent (),
    m_sendAckEvent (),
    m_sendDataEvent (),
    m_retry (0),
    //m_pktTx (0),
    m_pktData (0)

{
  /*m_cw = m_cwMin;
  m_nav = Simulator::Now ();
  m_localNav = Simulator::Now ();
  m_backoffRemain = Seconds (0);
  m_backoffStart = Seconds (0);*/
  m_sequence = 0;
  m_pktSequence = 0;
  m_seqRec = 0;
  m_ite = 0;
  m_discarded = 0;
Simulator::ScheduleNow (&THzMacCsma::SetAntenna, this);// initialization: turn antenna mode as Omnidirectional mode at all devices 
}
THzMacCsma::~THzMacCsma ()
{
  Clear ();
}
void
THzMacCsma::Clear ()
{
  //m_pktTx = 0;
  m_pktData = 0;
  m_pktQueue.clear ();
  m_seqList.clear ();

  m_pktRec = 0;
  m_throughput = 0;
  m_throughputAll = 0;
}

TypeId
THzMacCsma::GetTypeId (void)
{
  static TypeId tid = TypeId ("ns3::THzMacCsma")
    .SetParent<Object> ()
    .AddConstructor<THzMacCsma> ()
    .AddAttribute ("EnableRts",
                   "If true, RTS is enabled",
                   BooleanValue (false),
                   MakeBooleanAccessor (&THzMacCsma::m_rtsEnable),
                   MakeBooleanChecker ())   
    .AddAttribute ("CwMin",
                   "Minimum value of CW",
                   UintegerValue (15),
                   MakeUintegerAccessor (&THzMacCsma::m_cwMin),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("CwMax",
                   "Maximum value of CW",
                   UintegerValue (1023),
                   MakeUintegerAccessor (&THzMacCsma::m_cwMax),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("SlotTime",
                   "Time slot duration for MAC backoff",
                   TimeValue (MicroSeconds (8)),
                   MakeTimeAccessor (&THzMacCsma::m_slotTime),
                   MakeTimeChecker ())
    .AddAttribute ("SifsTime",
                   "Short Inter-frame Space",
                   TimeValue (NanoSeconds (1)),
                   MakeTimeAccessor (&THzMacCsma::m_sifs),
                   MakeTimeChecker ())
    .AddAttribute ("DifsTime",
                   "DFS Inter-frame Space",
                   TimeValue (MicroSeconds (3.25)),
                   MakeTimeAccessor (&THzMacCsma::m_difs),
                   MakeTimeChecker ())
    .AddAttribute ("BasicRate",
                   "Transmission Rate (bps) for Control Packets",
                   DoubleValue (2e10), // 20Gbps
                   MakeDoubleAccessor (&THzMacCsma::m_basicRate),
                   MakeDoubleChecker<double> ())
    .AddAttribute ("DataRate",
                   "Transmission Rate (bps) for Data Packets",
                   DoubleValue (1e11), // 100Gbps
                   MakeDoubleAccessor (&THzMacCsma::m_dataRate),
                   MakeDoubleChecker<double> ())
    .AddAttribute ("QueueLimit",
                   "Maximum packets to queue at MAC",
                   UintegerValue (20),
                   MakeUintegerAccessor (&THzMacCsma::m_queueLimit),
                   MakeUintegerChecker<uint32_t> ())
    .AddAttribute ("RtsRetryLimit",
                   "Maximum Limit for RTS Retransmission",
                   UintegerValue (5),
                   MakeUintegerAccessor (&THzMacCsma::m_rtsRetryLimit),
                   MakeUintegerChecker<uint16_t> ())
    .AddAttribute ("DataRetryLimit",
                   "Maximum Limit for Data Retransmission",
                   UintegerValue (5),
                   MakeUintegerAccessor (&THzMacCsma::m_dataRetryLimit),
                   MakeUintegerChecker<uint16_t> ())
    .AddTraceSource ("CtsTimeout",
                     "Trace Hookup for CTS Timeout",
                     MakeTraceSourceAccessor (&THzMacCsma::m_traceCtsTimeout))
    .AddTraceSource ("AckTimeout",
                     "Trace Hookup for ACK Timeout",
                     MakeTraceSourceAccessor (&THzMacCsma::m_traceAckTimeout))
    .AddTraceSource ("SendDataDone",
                     "Trace Hookup for sending a data",
                     MakeTraceSourceAccessor (&THzMacCsma::m_traceSendDataDone))
    .AddTraceSource ("Enqueue",
                     "Trace Hookup for enqueue a data",
                     MakeTraceSourceAccessor (&THzMacCsma::m_traceEnqueue))
    //add trace
    .AddTraceSource ("Throughput",
                     "Trace Hookup for Throughput",
                     MakeTraceSourceAccessor (&THzMacCsma::m_traceThroughput))
  ;
  return tid;
}
// ------------------------ Set Functions -----------------------------
void
THzMacCsma::SetAntenna ()
{
  NS_LOG_FUNCTION ("");
  double turnSpeed = 0;
  double MaxGain = 40;//dB
  double beamwidthDegrees = 360; 
  m_thzAD = m_device->GetDirAntenna ();
  m_thzAD->SetAttribute ("TuneRxTxMode", DoubleValue (2)); // set as omnidirectional 
  NS_LOG_DEBUG( "Tune as OmnidirectionalMode At node: "<< m_device -> GetNode () ->GetId() << " Antenna Mode: " <<m_thzAD->CheckAntennaMode() );
  m_thzAD->SetAttribute ("InitialAngle", DoubleValue (0.0));
  m_thzAD->SetMaxGain (MaxGain);    
  m_thzAD->SetBeamwidth (beamwidthDegrees);  
  m_thzAD->SetRxTurningSpeed (turnSpeed);
}
void
THzMacCsma::AttachPhy (Ptr<THzPhyNano> phy)
{
  m_phy = phy;
}
void
THzMacCsma::SetDevice (Ptr<THzNetDevice> dev)
{
  m_device = dev;
  SetCw (m_cwMin);
}
void
THzMacCsma::SetAddress (Mac48Address addr)
{
  NS_LOG_FUNCTION (addr);
  m_address = addr;
  // to help each node have different random seed
  uint8_t tmp[6];
  m_address.CopyTo (tmp);
  SeedManager::SetSeed (tmp[5]+9);
}
void
THzMacCsma::SetForwardUpCb (Callback<void, Ptr<Packet>, Mac48Address, Mac48Address> cb)
{
  m_forwardUpCb = cb;
}
void
THzMacCsma::SetCwMin (uint32_t cw)
{
  m_cwMin = cw;
}
void
THzMacCsma::SetCw (uint32_t cw)
{
  m_cw = cw;
}
void
THzMacCsma::SetSlotTime (Time duration)
{
  m_slotTime = duration;
}
// ------------------------ Get Functions -----------------------------
uint32_t
THzMacCsma::GetCw (void)
{
  return m_cw;
}
Time
THzMacCsma::GetSlotTime (void)
{
  return m_slotTime;
}
Time
THzMacCsma::GetSifs (void) const
{
  return m_sifs;
}
Time
THzMacCsma::GetDifs (void) const
{
  return m_difs;
}
uint32_t
THzMacCsma::GetBasicRate ()
{
  return m_basicRate;
}
uint32_t
THzMacCsma::GetDataRate ()
{
  return m_dataRate;
}
Mac48Address
THzMacCsma::GetAddress () const
{
  return this->m_address;
}

Mac48Address
THzMacCsma::GetBroadcast (void) const
{
  return Mac48Address::GetBroadcast ();
}
Time
THzMacCsma::GetCtrlDuration (uint16_t type)
{
  THzMacHeader header = THzMacHeader (m_address, m_address, type);
  //NS_LOG_FUNCTION ("ack size"<<header.GetSize ());
  return m_phy->CalTxDuration (header.GetSize (), 0, 1e11, 1e11);
}
Time
THzMacCsma::GetDataDuration (Ptr<Packet> p)
{
  return m_phy->CalTxDuration (0, p->GetSize (), 1e11, 1e11);
}
std::string
THzMacCsma::StateToString (State state)
{
  switch (state)
    {
      case IDLE:
        return "IDLE";
      case BACKOFF:
        return "BACKOFF";
      case WAIT_TX:
        return "WAIT_TX";
      case TX:
        return "TX";
      case WAIT_RX:
        return "WAIT_RX";
      case RX:
        return "RX";
      case COLL:
        return "COLL";
      default:
        return "??";
    }
}
// ----------------------- Queue Functions -----------------------------
bool
THzMacCsma::Enqueue (Ptr<Packet> packet, Mac48Address dest)
{
  NS_LOG_FUNCTION ( "dest" << dest << "#queue" << m_pktQueue.size () << 
                  "state" << m_state << "pktSize" << packet->GetSize ());
  NS_LOG_DEBUG("at node: "<<m_device->GetNode ()->GetId ());
  m_pktRec = packet->GetSize ();
  //++m_pktSequence;
 
  if (m_pktQueue.size () >= m_queueLimit)
    {
      return false;
    }
  m_traceEnqueue (m_device->GetNode ()->GetId (), m_device->GetIfIndex ());
  ++m_sequence;
  NS_LOG_DEBUG("enqueued seq: " << m_sequence);
  THzMacHeader header = THzMacHeader (m_address, dest, THZ_PKT_TYPE_DATA);
  header.SetSequence (m_sequence);
  packet->AddHeader (header);
  m_pktQueue.push_back (packet);

  PktTx ot;//to keep track of tstart and retries for each packet
  ot.retry = 0;
  //ot.rtsRetry = 0;
  ot.destination = dest;
  ot.packet = packet;
  ot.sequence = m_sequence;
  ot.tstart = Simulator::Now();
  
  m_pktData = m_pktQueue.front();
  m_pktQueue.pop_front ();
  if (m_pktData == 0)
    NS_ASSERT ("Queue has null packet");
  
  std::list<PktTx>::iterator it = m_pktTx.begin ();
  for (; it != m_pktTx.end (); ++it)
    {
      Ptr<Packet> data = it->packet;
      THzMacHeader dataHeader;
      data->PeekHeader (dataHeader);
      if (dataHeader.GetSequence() < ot.sequence && dataHeader.GetDestination() == ot.destination)
        {
          //NS_LOG_DEBUG("same dest tx ");
          m_pktTx.push_back (ot);
          return true;
        }
      }//for loop ends

  m_pktTx.push_back (ot);
  CheckResources(m_pktData);
  m_pktData = 0;
  return true;
}

void
THzMacCsma::CheckResources (Ptr<Packet> packet)
{//check if there is sufficient energy and memory here********************************
  THzMacHeader header;
  packet->PeekHeader (header);
  //NS_LOG_DEBUG("packet size : " << packet->GetSize ());
  if (header.GetDestination () != GetBroadcast () && m_rtsEnable == true)
    {
      if(m_device->GetNode ()->GetObject<THzEnergyModel> ()->BookEnergy(70))
        {
          SendRts (packet);
          return;
        }
      else Simulator::Schedule (MicroSeconds(8.0), &THzMacCsma::CheckResources, this, packet);
    }
  else
    {
      if(m_device->GetNode ()->GetObject<THzEnergyModel> ()->BookEnergy(65))
        {
          NS_LOG_DEBUG ("Rem Energy after SendData: "<<m_device->GetNode ()->GetObject<THzEnergyModel> ()->GetRemainingEnergy());
          SendData (packet);
          return;
        }
      else Simulator::Schedule (MicroSeconds(8.0), &THzMacCsma::CheckResources, this, packet);
    }   
}   

void
THzMacCsma::Backoff(Ptr<Packet> packet, uint32_t retry)
{
  NS_LOG_FUNCTION ("at node: "<<m_device->GetNode ()->GetId ());
  RngSeedManager seed;
  seed.SetSeed(static_cast<unsigned int>(time(0)));
  UniformVariable uv;
  uint32_t bo = uv.GetInteger (1, pow(double(2.0), double(retry)));
  m_backoffRemain = Seconds ((double)(bo) * GetSlotTime().GetSeconds ());
  NS_LOG_DEBUG("backoff time : "<< m_backoffRemain);    
  m_backoffTimeoutEvent = Simulator::Schedule (m_backoffRemain, &THzMacCsma::CheckResources, this, packet);
}
void
THzMacCsma::Dequeue ()
{
  NS_LOG_FUNCTION (m_pktQueue.size ());
  m_pktQueue.remove(m_pktData);
}

// ----------------------- Send Functions ------------------------------
void
THzMacCsma::SendRts (Ptr<Packet> packet)
{
  NS_LOG_FUNCTION ("at node: "<<m_device->GetNode ()->GetId ());
  
  THzMacHeader dataHeader;
  packet->PeekHeader (dataHeader);
  NS_LOG_DEBUG("Send RTS to " << dataHeader.GetDestination ()<<"from "<<m_address);
  Ptr<Packet> rtsPacket = Create<Packet> (0);
  THzMacHeader rtsHeader = THzMacHeader (m_address, dataHeader.GetDestination (), THZ_PKT_TYPE_RTS);
  rtsHeader.SetSequence (dataHeader.GetSequence());
  
  rtsHeader.SetDuration (Seconds(0));
  rtsPacket->AddHeader (rtsHeader);
  
  Time ctsTimeout = GetCtrlDuration (THZ_PKT_TYPE_RTS) 
                  + GetCtrlDuration (THZ_PKT_TYPE_CTS)
                  + 2*PicoSeconds(66)+NanoSeconds(10);
  
  NS_LOG_DEBUG("CTS timeout " << ctsTimeout<<"s");
     CtsTimeouts ct;
     ct.sequence = dataHeader.GetSequence();
     //NS_LOG_INFO ("scheduling ack timeout at:"<<Simulator::Now ()+ackTimeout + m_ackTimeout<<"seq"<<at.sequence);
     //ct.m_ctsTimeoutEvent = Simulator::Schedule (ackTimeout + m_ackTimeout, &THzMacCsma::AckTimeout, this, at.sequence);
     
       

  if (SendPacket (rtsPacket, 1))
    {
      //UpdateLocalNav (ctsTimeout);
      ct.m_ctsTimeoutEvent = Simulator::Schedule (ctsTimeout, &THzMacCsma::CtsTimeout, this, packet);
      m_ctsTimeouts.push_back (ct);
    }
  else
    {
      StartOver ();
    }
}
void
THzMacCsma::SendCts (Mac48Address dest, uint16_t sequence)
{
  NS_LOG_FUNCTION ("Send CTS to:" << dest<<"from "<<m_address);
  //NS_LOG_DEBUG("Send CTS to " << dest);
  Ptr<Packet> packet = Create<Packet> (0);
  THzMacHeader ctsHeader = THzMacHeader (m_address, dest, THZ_PKT_TYPE_CTS);
  
  //Time nav = duration - GetSifs () - GetCtrlDuration (THZ_PKT_TYPE_CTS);
  ctsHeader.SetDuration (Seconds(0));
  ctsHeader.SetSequence (sequence);
  packet->AddHeader (ctsHeader);
  SendPacket (packet, 1);
}
void
THzMacCsma::SendData (Ptr<Packet> packet)
{
  
  THzMacHeader header;
  packet->RemoveHeader (header);
  NS_LOG_FUNCTION ("at node: "<<m_device->GetNode ()->GetId ()<<" to: "<<header.GetDestination());
  if (header.GetDestination () == GetBroadcast ()) // Broadcast
    {
      m_addRecS = header.GetSource ();
      header.SetDuration (Seconds (0));
      //header.SetSequence (m_sequence);
      packet->AddHeader (header);
      SendPacket (packet, 0);// returns bool value.************************
      return;
    }

  if (header.GetDestination () != GetBroadcast ()) // Unicast
    {
      header.SetDuration (Seconds(0));
      //header.SetSequence (m_sequence);
      packet->AddHeader (header);
      m_ackTimeout = GetDataDuration (packet) + GetCtrlDuration (THZ_PKT_TYPE_ACK)+2*PicoSeconds(66)+NanoSeconds(10);

      SendPacket (packet, 1);// returns bool value*****************
      
      return;//call the ack timeout function from phy//****************you may send DataDuration+CtrlDuration to phy

      /*if (SendPacket (m_pktData, 1))
        {
          Time ackTimeout = GetDataDuration (m_pktData) + GetSifs () + GetCtrlDuration (THZ_PKT_TYPE_ACK) + GetSlotTime ();
          UpdateLocalNav (ackTimeout);
          m_ackTimeoutEvent = Simulator::Schedule (ackTimeout, &THzMacCsma::AckTimeout, this);
      }
      else
        {
          StartOver ();
        }*/
    }
  NS_LOG_FUNCTION ("# dest" << header.GetDestination () << "seq" << m_sequence << "q-size" << m_pktQueue.size());
  
}

void
THzMacCsma::ScheduleAckTimeout (Ptr<Packet> packet, Time ackTimeout)//added prototype to the header file
{
  NS_LOG_FUNCTION ("at node: "<<m_device->GetNode ()->GetId ());
  
  THzMacHeader header;
  //packet->RemoveHeader (header);//m_pktData
  packet->PeekHeader (header);
  
  //NS_LOG_FUNCTION ("packet type"<<header.GetType ());
  if (header.GetDestination () == GetBroadcast ()) // Broadcast
    {
      NS_LOG_INFO ("Broadcast packet");
      return;
    }
  else if(header.GetType () == THZ_PKT_TYPE_ACK)
    {
      NS_LOG_INFO ("Ack packet");
      return;
    }
  else if(header.GetType () == THZ_PKT_TYPE_RTS)
    {
      NS_LOG_INFO ("RTS packet");
      return;
    }
  else if(header.GetType () == THZ_PKT_TYPE_CTS)
    {
      NS_LOG_INFO ("CTS packet");
      return;
    }
  else if(header.GetDestination () != GetBroadcast () ) // Unicast
    {
      AckTimeouts at;
      at.sequence = header.GetSequence();
      NS_LOG_INFO ("scheduling ack timeout at:"<<Simulator::Now ()+ackTimeout + m_ackTimeout<<"seq"<<at.sequence);
      at.m_ackTimeoutEvent = Simulator::Schedule (ackTimeout + m_ackTimeout, &THzMacCsma::AckTimeout, this, at.sequence);
      at.packet = packet;
      m_ackTimeouts.push_back (at);
    }
  return;
}


void
THzMacCsma::SendAck (Mac48Address dest,uint16_t sequence)
{//set the m_ackTimeout here because SendData is not called for ack
  NS_LOG_FUNCTION ("to" << dest <<"sequence"<<sequence);
  
  Ptr<Packet> packet = Create<Packet> ();
  //Ptr<Packet> packet = Ptr<Packet> (new Packet ((0,false), m_byteTagList, m_packetTagList, (0,0)), false);
  THzMacHeader ackHeader = THzMacHeader (m_address, dest, THZ_PKT_TYPE_ACK);
  ackHeader.SetDuration (Seconds (0));
  ackHeader.SetSequence (sequence);
  packet->AddHeader (ackHeader);

  THzMacHeader header1;
  packet->RemoveHeader (header1);
  NS_LOG_INFO ("sequence"<<header1.GetSequence ());
  
  packet->AddHeader (header1);
  
  THzMacHeader header2;
  packet->PeekHeader (header2);
  NS_LOG_INFO ("sequence"<<header2.GetSequence ());
  //ackHeader.SetDuration (Seconds (0));
  
  SendPacket (packet, 1);
}
bool 
THzMacCsma::SendPacket (Ptr<Packet> packet, bool rate)
{
  NS_LOG_FUNCTION ( "now" << Simulator::Now ());//"state" << m_state <<
  THzMacHeader header;
  packet->PeekHeader (header);
  NS_LOG_INFO ("sequence"<<header.GetSequence ());
  //if (m_state == IDLE || m_state == WAIT_TX) {
  if (m_phy->SendPacket (packet, rate)) 
    {
      //PktTx ot;
      //ot.packet = packet;
      //m_pktTx.push_back (ot);   
      //m_pktTx = packet;//now a list of m_pktTx***************************************************************************
      return true;
    }
    
  return false;
}
void 
THzMacCsma::SendPacketDone (Ptr<Packet> packet)
{
  NS_LOG_FUNCTION ("at node: "<<m_device->GetNode ()->GetId ());
  std::list<PktTx>::iterator it = m_pktTx.begin ();
  for (; it != m_pktTx.end (); ++it)
    {
      //rts cts packets are not in the pktTx list********************
      if (it->packet== packet)
        {
          //m_pktTx.erase (it);// ReceiveDataDone will need this packet to calculate throughput.
          THzMacHeader header;
          packet->PeekHeader (header);
  
          switch (header.GetType ())
            {
              case THZ_PKT_TYPE_RTS:
              case THZ_PKT_TYPE_CTS:
                break;
              case THZ_PKT_TYPE_DATA:
                if (header.GetDestination () == GetBroadcast ())
                  {
                    //SendDataDone (true);
                    return;
                  }
	        break;
              case THZ_PKT_TYPE_ACK:
                break;
              default:
                break;
            }//switch ends
          return;
        }// if ends
    }//for loop ends
  
  NS_LOG_DEBUG ("Something is wrong!");//rts cts packets will show this
  return;//
}
void
THzMacCsma::SendDataDone (bool success, Ptr<Packet> packet)
{

  THzMacHeader header;
  packet->PeekHeader (header);
  std::list<PktTx>::iterator dit = m_pktTx.begin ();
  for (; dit != m_pktTx.end (); ++dit)
    {
      Ptr<Packet> data = dit->packet;
      THzMacHeader dataHeader;
      data->PeekHeader (dataHeader);
      NS_LOG_DEBUG ("data dest"<<dataHeader.GetDestination()<<"acked pack dest"<<header.GetDestination());
      if (dataHeader.GetSequence() > header.GetSequence() && dataHeader.GetDestination() == header.GetDestination())
        {
          NS_LOG_DEBUG ("same destination");
          Simulator::Schedule (Seconds(0.0), &THzMacCsma::CheckResources, this, data);
          break;
        }
    }//for loop ends

  m_tend = Simulator::Now ();
  NS_LOG_DEBUG (" end at " << m_tend);
  //NS_LOG_DEBUG (" seq sent : "<< sequence);
  std::list<PktTx>::iterator it = m_pktTx.begin ();
  for (; it != m_pktTx.end (); )
    {
      //NS_LOG_DEBUG (" packet found : "<< it->packet<<"Packet received"<<packet);
      if (it->sequence == header.GetSequence())//outer if
        {
          if (success)
            {
              NS_LOG_FUNCTION ("Success to transmit packet: "<<it->sequence<<"! at node: "<<m_device->GetNode ()->GetId ());
              m_traceSendDataDone (m_device->GetNode ()->GetId (), m_device->GetIfIndex (), true);
              m_timeRec = (m_tend-it->tstart);//this is the packet delay we want to plot*************
              m_throughput = it->packet->GetSize ()*8/m_timeRec.GetSeconds ();
              m_throughputAll += m_throughput;
              m_ite += 1;
              m_throughputavg = m_throughputAll/(m_ite);
              m_traceThroughput (m_throughputavg);
              NS_LOG_DEBUG (it->packet->GetSize () <<" bytes successfully transmitted during " << m_timeRec.GetSeconds () << " Seconds");
              NS_LOG_DEBUG ("  throughput : "<< m_throughput);
              NS_LOG_DEBUG ("  overall throughput : "<< m_throughputAll);
              NS_LOG_DEBUG ("  average throughput : "<< m_throughputavg);
              NS_LOG_UNCOND (" discarded packets: "<<m_discarded<<" successful packets: "<<m_ite<< " throughput: "<< m_throughput<<"average throughput : "<< m_throughputavg<<"! at node: "<<m_device->GetNode ()->GetId ());
              it = m_pktTx.erase (it);//= needed, cz it will hold the returned iterator
            } 
          else
            {
              m_discarded += 1;
              NS_LOG_UNCOND (" discarded packets : "<<m_discarded<<"! at node: "<<m_device->GetNode ()->GetId ());
              NS_LOG_FUNCTION ("Fail to transmit packet: "<<it->sequence <<"! at node: "<<m_device->GetNode ()->GetId ());
              m_traceSendDataDone (m_device->GetNode ()->GetId (), m_device->GetIfIndex (), false);
              it = m_pktTx.erase (it);
            }
      }//outer if ends
    else ++it;
  }//for loop ends

   //Now check if there is any other packet waiting in the list for the same destination;****************
   
   
}




void
THzMacCsma::StartOver ()
{
  NS_LOG_FUNCTION ("");
  m_pktQueue.push_front (m_pktData);
  m_backoffStart = Seconds (0);
  m_backoffRemain = Seconds (0);
  //CcaForDifs ();
}

// ---------------------- Receive Functions ----------------------------
void 
THzMacCsma::ReceiveRts (Ptr<Packet> packet) {
  NS_LOG_FUNCTION ("at node: "<<m_device->GetNode ()->GetId ());
  m_device->GetNode ()->GetObject<THzEnergyModel> ()->BookEnergy(1);
  THzMacHeader header;
  packet->PeekHeader (header);
  
  if (header.GetDestination () != m_address)
    {
      NS_LOG_INFO ("RTS not for me");
      return;
    }
  
  //check if you have resources
  if(m_device->GetNode ()->GetObject<THzEnergyModel> ()->BookEnergy(24))
    {
      //m_sendCtsEvent = Simulator::Schedule (GetSifs (), &THzMacCsma::SendCts, this,
      DataTimeouts dt;
      dt.sequence = header.GetSequence();
      Time dataTimeout = GetCtrlDuration (THZ_PKT_TYPE_CTS) 
                  + NanoSeconds(20)//txtime of a 256 bytes packet
                  + 2*PicoSeconds(66);
     
      dt.m_dataTimeoutEvent = Simulator::Schedule (dataTimeout, &THzMacCsma::DataTimeout, this, header.GetSequence());
      m_dataTimeouts.push_back (dt);
      SendCts(header.GetSource (), header.GetSequence());
      return;
    } 
  else NS_LOG_INFO ("Insufficient energy: "<<m_device->GetNode ()->GetObject<THzEnergyModel> ()->GetRemainingEnergy());
}
void 
THzMacCsma::ReceiveCts (Ptr<Packet> packet)
{
  NS_LOG_FUNCTION ("at node: "<<m_device->GetNode ()->GetId ());
  THzMacHeader header;
  packet->RemoveHeader (header);
  
  if (header.GetDestination () != m_address)
    {
      NS_LOG_INFO ("CTS not for me");
      return;
    }
  NS_LOG_INFO ("header seq:"<<header.GetSequence ());
  std::list<CtsTimeouts>::iterator cit = m_ctsTimeouts.begin ();
  for (; cit != m_ctsTimeouts.end (); ++cit)
    {
      NS_LOG_INFO ("cit seq:"<<cit->sequence);
      if (cit->sequence == header.GetSequence ())
        {
          //NS_LOG_INFO ("Inside inner if");
          cit->m_ctsTimeoutEvent.Cancel ();
          cit = m_ctsTimeouts.erase(cit);
          break;
        }  
    }//for loop ends

  //loop through the pktTx list to see if a there is a packet destined for cts source// like one way handshake***********************
  std::list<PktTx>::iterator it = m_pktTx.begin ();
  for (; it != m_pktTx.end (); ++it)
    {
      Ptr<Packet> data = it->packet;
      THzMacHeader dataHeader;
      data->PeekHeader (dataHeader);
      if (dataHeader.GetSequence() == header.GetSequence() && dataHeader.GetDestination() == header.GetSource())
        {
          SendData(data);
          return;
        }
      }//for loop ends
  return;
}

void 
THzMacCsma::ReceiveData (Ptr<Packet> packet)
{
  NS_LOG_FUNCTION ("at node: "<<m_device->GetNode ()->GetId ()<<"Rem Energy"<<m_device->GetNode ()->GetObject<THzEnergyModel> ()->GetRemainingEnergy());
  THzMacHeader header;
  packet->RemoveHeader (header);

  if  (m_rtsEnable == false)// for aloha
    {
      if(m_device->GetNode ()->GetObject<THzEnergyModel> ()->BookEnergy(20) !=true ) 
        {
          NS_LOG_INFO ("Insufficient energy");
          return;
       }
    }
  NS_LOG_FUNCTION ("Rem Energy after booking: "<<m_device->GetNode ()->GetObject<THzEnergyModel> ()->GetRemainingEnergy());
  if (header.GetDestination () == GetBroadcast ())
    {
      //m_state = IDLE;
      
      if (IsNewSequence (header.GetSource (), header.GetSequence ()))
        {
          m_forwardUpCb (packet, header.GetSource (), header.GetDestination ());
	}
      //CcaForDifs ();
      return;
    }	
  
 
  if (header.GetDestination () !=  m_address) // destined not to me
    { 
      if  (m_rtsEnable == false) m_device->GetNode ()->GetObject<THzEnergyModel> ()->ReturnEnergy(4);
      return;
    } 
  NS_LOG_INFO ("header seq:"<<header.GetSequence ());
  std::list<DataTimeouts>::iterator dit = m_dataTimeouts.begin ();
  for (; dit != m_dataTimeouts.end (); ++dit)
    {
      NS_LOG_INFO ("dit seq:"<<dit->sequence);
      if (dit->sequence == header.GetSequence ())
        {
          //NS_LOG_INFO ("Inside inner if");
          dit->m_dataTimeoutEvent.Cancel ();
          dit = m_dataTimeouts.erase(dit);
          break;
        }  
    }//for loop ends
    
  //m_sendAckEvent = Simulator::Schedule (GetSifs (), &THzMacCsma::SendAck, this, header.GetSource ());
  SendAck (header.GetSource (), header.GetSequence ());

  if (IsNewSequence (header.GetSource (), header.GetSequence ()))
    {    
      m_forwardUpCb (packet, header.GetSource (), header.GetDestination ());
    }
  return;
}
void 
THzMacCsma::ReceiveAck (Ptr<Packet> packet)
{
  NS_LOG_FUNCTION ("at node: "<<m_device->GetNode ()->GetId ()<<" now:"<<Simulator::Now ());
  
  THzMacHeader header;
  packet->PeekHeader (header);
  NS_LOG_INFO ("sequence"<<header.GetSequence ()<<" at node: "<<m_device->GetNode ()->GetId ());
  
  if (header.GetDestination () == m_address)
    {
      //NS_LOG_INFO ("Inside outer if");
      std::list<AckTimeouts>::iterator it = m_ackTimeouts.begin ();
      for (; it != m_ackTimeouts.end (); ++it)
        {
          //NS_LOG_INFO ("it seq:"<<it->sequence);
          if (it->sequence == header.GetSequence ())
            {
              NS_LOG_INFO ("cancelling ack timeout");
              it->m_ackTimeoutEvent.Cancel ();
              SendDataDone (true, it->packet);
              it = m_ackTimeouts.erase(it);
              return;
            }
        }//for loop ends
    } 
  else  NS_LOG_INFO ("ACK not for me");
  // create another function after enqueue to pick the next packet from the queue***********************
}


void
THzMacCsma::ReceivePacket (Ptr<THzPhyNano> phy, Ptr<Packet> packet)
{
  NS_LOG_FUNCTION ("at node: "<<m_device->GetNode ()->GetId ());
  
  switch (m_state)
    {
      case WAIT_TX:
      case RX:
      case WAIT_RX:
      case BACKOFF:
      case IDLE:
        m_state = RX;
        break;
      case TX:
      case COLL:
        break;
    }
}
void 
THzMacCsma::ReceivePacketDone (Ptr<THzPhyNano> phy, Ptr<Packet> packet, bool success)
{
  NS_LOG_FUNCTION ("success?" << success<<"at node: "<<m_device->GetNode ()->GetId ()<<" now: "<<Simulator::Now ());
  
  m_seqRec = m_sequence;//why is this for?********************************************************************************************
  
  THzMacHeader header;
  packet->PeekHeader (header);
  NS_LOG_INFO ("sequence"<<header.GetSequence ());
  if (!success)
    {
      NS_LOG_DEBUG ("The packet is not encoded correctly. Drop it!");
      return;
    }
  
  switch (header.GetType ())
    {
      case THZ_PKT_TYPE_RTS:
        ReceiveRts (packet);
        break;
      case THZ_PKT_TYPE_CTS:
        ReceiveCts (packet);
        break;
      case THZ_PKT_TYPE_DATA:
        ReceiveData (packet);
        break;
      case THZ_PKT_TYPE_ACK:
        ReceiveAck (packet);
        break;
      default:
        //CcaForDifs ();
        break;
    }
}
// -------------------------- Timeout ----------------------------------
void
THzMacCsma::CtsTimeout (Ptr<Packet> packet)
{
  THzMacHeader header;
  packet->PeekHeader (header);
  NS_LOG_FUNCTION ("!!! CTS timeout !!! at node: "<<m_device->GetNode ()->GetId ()<<" for packet: "<<header.GetSequence());
  //NS_LOG_UNCOND ("!!! CTS timeout !!! ");
  // Retransmission is over the limit. Drop it!
  m_traceCtsTimeout (m_device->GetNode ()->GetId (), m_device->GetIfIndex ());
  m_device->GetNode ()->GetObject<THzEnergyModel> ()->ReturnEnergy(66);
  
  std::list<CtsTimeouts>::iterator cit = m_ctsTimeouts.begin ();
  for (; cit != m_ctsTimeouts.end ();)
    {
      NS_LOG_INFO ("cit seq:"<<cit->sequence);
      if (cit->sequence == header.GetSequence ())
        {
          //NS_LOG_INFO ("Inside inner if");
          cit = m_ctsTimeouts.erase(cit);
          break;
        }
      else  ++cit;
    }//for loop ends

  std::list<PktTx>::iterator it = m_pktTx.begin ();
  for (; it != m_pktTx.end (); ++it)
    {
      if (it->sequence == header.GetSequence())
        {
          NS_LOG_DEBUG ("retry: "<<it->retry<<" for packet:"<<it->sequence);
          it->backoff = true;
          it->retry = it->retry + 1;
          NS_LOG_DEBUG ("retry: "<<it->retry);
          if (it->retry>= 5)
            {
              SendDataDone (false, packet);
              return;              
              //m_pktTx.erase (it);
            }
          else
            Backoff(it->packet, it->retry);
          return;
        }//outer if ends
    }//for loop ends
  
}
void
THzMacCsma::AckTimeout (uint16_t sequence)
{
  NS_LOG_FUNCTION ("now"<<Simulator::Now ());
  NS_LOG_DEBUG ("!!! ACK timeout !!! for packet: "<<sequence<<" at node: "<<m_device->GetNode ()->GetId ());
  NS_LOG_INFO ("Remaining energy: "<<m_device->GetNode ()->GetObject<THzEnergyModel> ()->GetRemainingEnergy());
  m_traceAckTimeout (m_device->GetNode ()->GetId (), m_device->GetIfIndex ());
  m_device->GetNode ()->GetObject<THzEnergyModel> ()->ReturnEnergy(1);

  std::list<AckTimeouts>::iterator ait = m_ackTimeouts.begin ();
  for (; ait != m_ackTimeouts.end (); )
     {
      //NS_LOG_INFO ("it seq:"<<it->sequence);
      if (ait->sequence == sequence)
         {
          ait = m_ackTimeouts.erase(ait);
          break;
         }
       else ++ait;
      }//for loop ends

  std::list<PktTx>::iterator it = m_pktTx.begin ();
  for (; it != m_pktTx.end (); ++it)
     {
      if (it->sequence == sequence)
        {
         // Retransmission is over the limit. Drop it!
          NS_LOG_DEBUG ("retry: "<<it->retry<<" for packet:"<<it->sequence);
          it->retry = it->retry + 1;
          NS_LOG_DEBUG ("retry: "<<it->retry);
          if (it->retry >= 5)
            {
              SendDataDone (false, it->packet);
              return;
              //m_pktTx.erase (it);
            }
          else
              Backoff(it->packet, it->retry);
              return;
        }//outer if ends
      }//for loop ends
}
void
THzMacCsma::DataTimeout (uint16_t sequence)
{
  NS_LOG_FUNCTION ("now"<<Simulator::Now ());
  NS_LOG_DEBUG ("!!! Data timeout !!! for packet: "<<sequence<<" at node: "<<m_device->GetNode ()->GetId ());
  
  m_device->GetNode ()->GetObject<THzEnergyModel> ()->ReturnEnergy(20);

  std::list<DataTimeouts>::iterator dit = m_dataTimeouts.begin ();
  for (; dit != m_dataTimeouts.end (); ++dit)
   {
    //NS_LOG_INFO ("dit seq:"<<dit->sequence);
    if (dit->sequence == sequence)
       {
        
        dit = m_dataTimeouts.erase(dit);
        return;
       }
    }//for loop ends
}
// --------------------------- ETC -------------------------------------
bool
THzMacCsma::IsNewSequence (Mac48Address addr, uint16_t seq)
{
  std::list<std::pair<Mac48Address, uint16_t> >::iterator it = m_seqList.begin ();
  for (; it != m_seqList.end (); ++it)
    {
      if (it->first == addr)
        {
          if (it->second == 65536 && seq < it->second)
            {
              it->second = seq;
              return true;
            }
          else if (seq > it->second)
            {
              it->second = seq;
              return true;
            }
          else
            {
              return false;
            }
         }
    }
  std::pair<Mac48Address, uint16_t> newEntry;
  newEntry.first = addr;
  newEntry.second = seq;
  m_seqList.push_back (newEntry);
  return true;
}
void
THzMacCsma::DoubleCw ()
{
  if (m_cw * 2 > m_cwMax)
    {
      m_cw = m_cwMax;
    }
  else
    {
      m_cw = m_cw * 2;
    }
}
// Nodes can start backoff procedure at different time because of propagation 
// delay and processing jitter (it's very small but matter in simulation), 
Time
THzMacCsma::RoundOffTime (Time time)
{
  int64_t realTime = time.GetMicroSeconds ();
  int64_t slotTime = GetSlotTime ().GetMicroSeconds ();
  if (realTime % slotTime >= slotTime / 2)
    {
      return Seconds (GetSlotTime().GetSeconds () * (double)(realTime / slotTime + 1));
    }
  else
    {
      return Seconds (GetSlotTime().GetSeconds () * (double)(realTime / slotTime));
    }
}

} // namespace ns3
